-- Create a private bucket for user exports
insert into storage.buckets (id, name, public)
values ('exports', 'exports', false)
on conflict (id) do nothing;

-- Ensure RLS is enabled for storage (already done, but good practice to assume nothing)
alter table storage.objects enable row level security;

-- Policy: Users can only view their own properties (files named with their user ID as prefix usually)
-- But for Signed URLs generated by server, RLS might not be hit if using service key.
-- However, if we access via Client, we need RLS.
-- Let's define: Users can access files in 'exports' folder where path starts with their user_id.

create policy "Users can view own exports"
on storage.objects for select
using (
  bucket_id = 'exports' AND
  auth.uid()::text = (storage.foldername(name))[1]
);

-- We don't necessarily need an Insert policy if only the Server Action (using Service Role?) uploads.
-- But if we use the User's client in the server action (which we usuall do with createClient()), 
-- then we fail RLS if we don't have an Insert policy.
-- NOTE: In Next.js Server Actions with @supabase/ssr, we usually use the user's session.
-- So we DO need an INSERT policy.

create policy "Users can upload own exports"
on storage.objects for insert
with check (
  bucket_id = 'exports' AND
  auth.uid()::text = (storage.foldername(name))[1]
);

-- Allow deletion too, maybe for cleanup later
create policy "Users can delete own exports"
on storage.objects for delete
using (
  bucket_id = 'exports' AND
  auth.uid()::text = (storage.foldername(name))[1]
);
